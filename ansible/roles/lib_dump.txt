===== apps/defaults/main.yml =====
    ---
    apps_mode: core  # core | full
    
    apps_mail_variant: thunderbird  # thunderbird | betterbird | none
    
    apps_enable_heavy_media: false      # obs-studio
    apps_enable_creative: false         # inkscape, gimp
    apps_enable_private_messaging: false # signal
    apps_enable_uni_apps: false         # graphviz/gephi or keep those in devtools/uni if you prefer
    
    apps_pacman_core:
      - firefox
      - chromium
      - libreoffice-fresh
      - vlc
    
    apps_pacman_media_heavy:
      - obs-studio
    
    apps_pacman_creative:
      - inkscape
      - gimp
    
    apps_pacman_private_messaging:
      - signal-desktop
    
    apps_pacman_uni:
      - graphviz
      - gephi
    
    apps_aur_mail_betterbird:
      - betterbird-bin
    
    apps_extra_pacman: []
    apps_extra_aur: []
    apps_extra_flatpak: []

===== apps/tasks/main.yml =====
    ---
    - name: Apps | Apply mode defaults
      ansible.builtin.set_fact:
        apps_enable_heavy_media: "{{ true if apps_mode in ['full'] else apps_enable_heavy_media }}"
        apps_enable_creative: "{{ true if apps_mode in ['full'] else apps_enable_creative }}"
        apps_enable_private_messaging: "{{ true if apps_mode in ['private', 'full'] else apps_enable_private_messaging }}"
        apps_enable_uni_apps: "{{ true if apps_mode in ['uni', 'full'] else apps_enable_uni_apps }}"
      when: apps_mode != 'core'
    
    - name: Apps | Compute package selection
      ansible.builtin.set_fact:
        _apps_pacman: >-
          {{
            (apps_pacman_core | default([]))
            + ((apps_pacman_media_heavy | default([])) if (apps_enable_heavy_media | bool) else [])
            + ((apps_pacman_creative | default([])) if (apps_enable_creative | bool) else [])
            + ((apps_pacman_private_messaging | default([])) if (apps_enable_private_messaging | bool) else [])
            + ((apps_pacman_uni | default([])) if (apps_enable_uni_apps | bool) else [])
            + (apps_extra_pacman | default([]))
          }}
        _apps_aur: >-
          {{
            (
              (apps_aur_mail_betterbird | default([]))
              if apps_mail_variant == 'betterbird' else []
            )
            + (apps_extra_aur | default([]))
          }}
        _apps_flatpak: "{{ apps_extra_flatpak | default([]) }}"
    
    - name: Apps | Install selected packages
      ansible.builtin.include_role:
        name: packages
        tasks_from: install.yml
      vars:
        packages_pacman_packages: "{{ _apps_pacman | unique }}"
        packages_aur_packages: "{{ _apps_aur | unique }}"
        packages_flatpak_packages: "{{ _apps_flatpak | unique }}"

===== baseline/defaults/main.yml =====
    ---
    baseline_pacman_packages:
      - xclip
      - neovim
      - wget
      - curl
      - ripgrep
      - fd
      - bat
      - fzf
      - eza
      - git
      - git-delta
      - zsh
      - zsh-completions
      - bash
      - bash-completion
      - man-db
      - man-pages
      - unzip
      - zip
      - python-uv
    
    baseline_aur_packages:
      - zsh-antidote

===== baseline/tasks/main.yml =====
    ---
    - name: Baseline | Install core CLI packages
      ansible.builtin.include_role:
        name: packages
        tasks_from: install
      vars:
        packages_pacman_packages: "{{ baseline_pacman_packages | default([]) }}"
        packages_aur_packages: "{{ baseline_aur_packages | default([]) }}"

===== bootstrap/defaults/main.yml =====
    ---
    bootstrap_install_aur_helper: true
    bootstrap_aur_helper: "paru"   # or yay
    
    bootstrap_min_packages:
      - base-devel
      - git
      - curl
      - rsync
      - sudo
      - xdg-user-dirs
    
    bootstrap_enable_timesyncd: true
    bootstrap_enable_paccache: true
    
    # Mirrors
    bootstrap_use_reflector: false
    bootstrap_reflector_countries: ["Austria", "Germany"]
    bootstrap_reflector_protocols: ["https"]
    bootstrap_reflector_latest: 20
    bootstrap_reflector_sort: "rate"
    bootstrap_reflector_save_path: "/etc/pacman.d/mirrorlist"
    bootstrap_reflector_run_on_boot: true   # timer
    bootstrap_reflector_run_now: true       # immediate refresh
    
    # Pacman repos
    bootstrap_pacman_multilib: true
    bootstrap_pacman_parallel_downloads: 5
    bootstrap_pacman_download_user: "alpm"

===== bootstrap/handlers/main.yml =====
    ---
    - name: Restart systemd-timesyncd
      ansible.builtin.systemd:
        name: systemd-timesyncd
        state: restarted
      become: true
    
    - name: Restart reflector
      ansible.builtin.systemd:
        name: reflector.timer
        state: restarted
      become: true

===== bootstrap/tasks/main.yml =====
    ---
    - name: Bootstrap | Render pacman.conf from template
      become: true
      ansible.builtin.template:
        src: pacman.conf.j2
        dest: /etc/pacman.conf
        owner: root
        group: root
        mode: "0644"
    
    - name: Bootstrap | Initialize pacman keyring (best effort)
      become: true
      ansible.builtin.command: pacman-key --init
      changed_when: false
      failed_when: false
    
    - name: Bootstrap | Populate archlinux keyring
      become: true
      ansible.builtin.command: pacman-key --populate archlinux
      changed_when: false
    
    - name: Bootstrap | Refresh archlinux-keyring before upgrade
      become: true
      community.general.pacman:
        name: archlinux-keyring
        state: latest
        update_cache: true
    
    - name: Bootstrap | Full system upgrade
      become: true
      community.general.pacman:
        upgrade: true
        update_cache: true
    
    - name: Bootstrap | Install minimal bootstrap packages
      become: true
      community.general.pacman:
        name: >-
          {{
            bootstrap_min_packages
            + (['pacman-contrib'] if bootstrap_enable_paccache else [])
            + (['reflector'] if bootstrap_use_reflector else [])
          }}
        state: present
    
    - name: Bootstrap | Enable and start systemd-timesyncd
      become: true
      ansible.builtin.systemd:
        name: systemd-timesyncd
        enabled: true
        state: started
      when: bootstrap_enable_timesyncd | bool
    
    - name: Bootstrap | Enable paccache timer
      become: true
      ansible.builtin.systemd:
        name: paccache.timer
        enabled: true
        state: started
      when: bootstrap_enable_paccache | bool
    
    - name: Bootstrap | Run xdg-user-dirs-update for the login user
      ansible.builtin.command: xdg-user-dirs-update
      become: true
      become_user: "{{ ansible_facts.user_id }}"
      changed_when: false
    
    # --- Reflector (optional) ---
    - name: Bootstrap | Render reflector.conf
      become: true
      ansible.builtin.template:
        src: reflector.conf.j2
        dest: /etc/xdg/reflector/reflector.conf
        owner: root
        group: root
        mode: "0644"
      when: bootstrap_use_reflector | bool
      notify: restart reflector
    
    - name: Bootstrap | Enable reflector timer
      ansible.builtin.systemd:
        name: reflector.timer
        enabled: true
        state: started
      when: bootstrap_use_reflector | bool
    
    - name: Bootstrap | Disable reflector timer
      become: true
      ansible.builtin.systemd:
        name: reflector.timer
        enabled: false
        state: stopped
      when:
        - bootstrap_use_reflector | bool
        - not (bootstrap_reflector_run_on_boot | bool)
    
    - name: Bootstrap | Run reflector once now
      become: true
      ansible.builtin.command: reflector --config /etc/xdg/reflector/reflector.conf
      changed_when: false
      when:
        - bootstrap_use_reflector | bool
        - bootstrap_reflector_run_now | bool
    # -- Build User and privilege escalation
    - name: Bootstrap | Ensure sudo is installed
      become: true
      community.general.pacman:
        name: sudo
        state: present
    
    - name: Bootstrap | Ensure AUR builder user exists
      become: true
      ansible.builtin.user:
        name: aurbuilder
        create_home: true
        shell: /usr/bin/nologin
    
    - name: Bootstrap | Allow aurbuilder to run pacman without password
      become: true
      ansible.builtin.copy:
        dest: /etc/sudoers.d/10-aurbuilder
        owner: root
        group: root
        mode: "0440"
        content: |
          aurbuilder ALL=(ALL) NOPASSWD: /usr/bin/pacman
        validate: "visudo -cf %s"
    
    
    # --- AUR helper (optional) ---
    - name: Bootstrap | Install AUR helper prerequisites
      become: true
      community.general.pacman:
        name:
          - base-devel
          - git
          - cargo
          - zsh
        state: present
    
    - name: Bootstrap | Check if AUR helper is already installed
      ansible.builtin.stat:
        path: "/usr/bin/{{ bootstrap_aur_helper }}"
      register: bootstrap_aur_helper_stat
      when: bootstrap_install_aur_helper | bool
    
    - name: Bootstrap | Clone AUR helper # noqa: latest[git]
      ansible.builtin.git:
        repo: "https://aur.archlinux.org/{{ bootstrap_aur_helper }}.git"
        dest: "/tmp/{{ bootstrap_aur_helper }}"
        update: false
      when:
        - bootstrap_install_aur_helper | bool
        - not bootstrap_aur_helper_stat.stat.exists
    
    - name: Bootstrap | Build AUR helper package (user)
      ansible.builtin.command: makepkg -s --noconfirm
      args:
        chdir: "/tmp/{{ bootstrap_aur_helper }}"
      when:
        - bootstrap_install_aur_helper | bool
        - not bootstrap_aur_helper_stat.stat.exists
      changed_when: true
    
    - name: Bootstrap | Find built paru package (prefer non-debug)
      ansible.builtin.find:
        paths: "/tmp/{{ bootstrap_aur_helper }}"
        patterns:
          - "{{ bootstrap_aur_helper }}-[0-9]*.pkg.tar.*"
        file_type: file
      when:
        - bootstrap_install_aur_helper | bool
        - not bootstrap_aur_helper_stat.stat.exists
      changed_when: true
      register: bootstrap_pkg_find
    
    - name: Bootstrap | Install AUR helper package (root)
      ansible.builtin.command: "pacman -U --noconfirm {{ (bootstrap_pkg_find.files | map(attribute='path') | list | first) }}"
      when:
        - bootstrap_install_aur_helper | bool
        - not bootstrap_aur_helper_stat.stat.exists
      become: true
      changed_when: true
    
    # Systemd
    
    - name: Check if systemd-boot is used
      become: true
      ansible.builtin.stat:
        path: /boot/loader/entries
      register: bootstrap_systemd_boot
    
    
    - name: Enable and start systemd-boot-update.service
      become: true
      ansible.builtin.systemd:
        name: systemd-boot-update.service
        enabled: true
        state: started
      when:
        - bootstrap_systemd_boot.stat.exists
        - ansible_service_mgr == "systemd"
    
    # User setup
    - name: Ensure default shell is /usr/bin/zsh for "{{ ansible_user }}"
      become: true
      ansible.builtin.user:
        name: "{{ ansible_user }}"
        shell: /usr/bin/zsh

===== desktop/defaults/main.yml =====
    ---
    desktop_enable_qtile: true
    desktop_enable_kde: false
    
    desktop_enable_dm: true
    desktop_dm: sddm
    
    desktop_enable_gpu_drivers: true
    desktop_force_gpu: "auto"     # auto|amd|intel|nvidia|vm
    desktop_use_wayland_helpers: true
    
    
    desktop_shared_pacman_packages:
      - kitty
      - thunar
      - evince
      - zathura
      - feh
      - flameshot
      - xdg-utils
      - xdg-user-dirs
      - networkmanager
      - rofi
      - xclip          # clipboard backend
      - clipmenu       # clipboard manager (rofi-friendly)
    
      # audio (pipewire)
      - pipewire
      - wireplumber
      - pipewire-alsa
      - pipewire-pulse
      - pavucontrol   # optional but practical
    
      # bluetooth plumbing
      - bluez
      - bluez-utils
    
      # wayland x interaction
      - xorg-xwayland # for wayland
    
      # gpu
      - mesa
      - mesa-utils
    
    
    desktop_qtile_pacman_packages:
      # X11 basics (if you run qtile on Xorg; keep minimal)
      - xorg-server
      - xorg-xrandr
      # qtile necessities
      - qtile
      - dunst
      - picom
      - polkit-gnome    # polkit agent for non-KDE sessions (important)
    
    desktop_kde_pacman_packages:
      - plasma-desktop
      - plasma-workspace
      - xdg-desktop-portal-kde
      - kde-gtk-config
      - kdeplasma-addons
    
    desktop_enable_fonts: true
    desktop_font_packages:
      - ttf-dejavu
      - noto-fonts
      - noto-fonts-cjk
      - noto-fonts-emoji
      - ttf-jetbrains-mono-nerd

===== desktop/tasks/dm.yml =====
    ---
    - name: Desktop | Install display manager
      ansible.builtin.include_role:
        name: packages
        tasks_from: install
      vars:
        packages_pacman_packages:
          - "{{ desktop_dm | default('sddm') }}"
    
    - name: Desktop | Enable display manager service
      become: true
      ansible.builtin.systemd:
        name: "{{ (desktop_dm | default('sddm')) }}.service"
        enabled: true
        state: started

===== desktop/tasks/gpu.yml =====
    ---
    - name: Desktop | Detect GPU (lspci)
      ansible.builtin.command: lspci -nnk
      register: desktop_lspci
      changed_when: false
    
    - name: Desktop | Classify GPU vendor
      ansible.builtin.set_fact:
        desktop_gpu_vendor: >-
          {% if (desktop_force_gpu | default('auto')) != 'auto' %}
          {{ desktop_force_gpu }}
          {% else %}
          {% set s = desktop_lspci.stdout | lower %}
          {% if 'nvidia' in s %}
          nvidia
          {% elif 'amd' in s or 'advanced micro devices' in s or 'ati' in s %}
          amd
          {% elif 'intel' in s %}
          intel
          {% elif 'virtio' in s or 'qxl' in s or 'vmware' in s %}
          vm
          {% else %}
          unknown
          {% endif %}
          {% endif %}
    
    - name: Desktop | Debug GPU vendor
      ansible.builtin.debug:
        msg: "Detected GPU vendor: {{ desktop_gpu_vendor }}"
    
    # --- AMD graphics (no compute) ---
    - name: Desktop | Install GPU drivers (AMD)
      become: true
      community.general.pacman:
        name:
          - vulkan-radeon
          - libva-mesa-driver
          - mesa-vdpau
        state: present
      when: desktop_gpu_vendor == 'amd'
    
    # --- Intel graphics (no compute) ---
    - name: Desktop | Install GPU drivers (Intel)
      become: true
      community.general.pacman:
        name:
          - vulkan-intel
          - intel-media-driver
        state: present
      when: desktop_gpu_vendor == 'intel'
    
    # --- NVIDIA graphics (no compute) ---
    - name: Desktop | Install GPU drivers (NVIDIA)
      become: true
      community.general.pacman:
        name:
          - nvidia
          - nvidia-utils
          - egl-wayland
        state: present
      when: desktop_gpu_vendor == 'nvidia'
    
    # --- VM fallback (usually already ok with mesa; keep tiny) ---
    - name: Desktop | Install GPU helpers (VM)
      become: true
      community.general.pacman:
        name:
          - mesa
        state: present
      when: desktop_gpu_vendor == 'vm'

===== desktop/tasks/kde.yml =====
    ---
    - name: Desktop | Install KDE packages
      ansible.builtin.include_role:
        name: packages
        tasks_from: install
      vars:
        packages_pacman_packages: "{{ desktop_kde_pacman_packages | default([]) }}"

===== desktop/tasks/main.yml =====
    ---
    - name: Desktop | Shared
      ansible.builtin.import_tasks: shared.yml
    
    - name: Desktop | Display manager
      ansible.builtin.import_tasks: dm.yml
      when: desktop_enable_dm | bool
    
    - name: Desktop | Qtile
      ansible.builtin.import_tasks: qtile.yml
      when: desktop_enable_qtile | bool
    
    - name: Desktop | KDE
      ansible.builtin.import_tasks: kde.yml
      when: desktop_enable_kde | bool
    
    - name: Desktop | GPU drivers
      ansible.builtin.include_tasks: gpu.yml
      when: desktop_enable_gpu_drivers | default(true) | bool
    
    - name: Desktop | Install fonts
      become: true
      community.general.pacman:
        name: "{{ desktop_font_packages | default([]) }}"
        state: present
      when:
        - desktop_enable_fonts | default(true) | bool
        - (desktop_font_packages | default([])) | length > 0

===== desktop/tasks/qtile.yml =====
    ---
    - name: Desktop | Install Qtile packages
      ansible.builtin.include_role:
        name: packages
        tasks_from: install
      vars:
        packages_pacman_packages: "{{ desktop_qtile_pacman_packages | default([]) }}"
        packages_aur_packages: "{{ desktop_qtile_aur_packages | default([]) }}"

===== desktop/tasks/shared.yml =====
    ---
    - name: Desktop | Install shared desktop packages
      ansible.builtin.include_role:
        name: packages
        tasks_from: install
      vars:
        packages_pacman_packages: "{{ desktop_shared_pacman_packages | default([]) }}"
        packages_aur_packages: "{{ desktop_shared_aur_packages | default([]) }}"

===== devtools/defaults/main.yml =====
    ---
    # devtools_mode: core | full | work
    devtools_mode: core
    
    # Optional feature toggles (only a few; keep it sane)
    devtools_enable_containers: false     # docker/docker-compose
    devtools_enable_tex: true             # you said pandoc->pdf on almost any machine
    devtools_enable_tex_extra: false      # latexextra/pictures (uni/admin)
    devtools_enable_lang: true            # rustup/go
    devtools_enable_admin: false          # ansible (and maybe later etckeeper)
    
    # ---- Canonical package groups (pacman/aur only) ----
    
    devtools_pacman_core:
      - python-uv
      - pandoc
      - gcc
      - gdb
      - valgrind
      - make
      - cmake
      - ninja
      - pkgconf
      - shellcheck
      - shfmt
      - hyperfine
      - just
    
    devtools_aur_core: []
      # - mise # via aur is pain as self-update wont work
    
    devtools_pacman_lang:
      # - rustup # rustup conflicts with rust build chain this way, removed for now
      - go
    
    devtools_pacman_containers:
      - docker
      - docker-compose
    
    devtools_pacman_admin:
      - ansible
    
    devtools_pacman_tex_base:
      - texlive-core
    
    devtools_pacman_tex_extra:
      - texlive-latexextra
      - texlive-pictures
    
    # Work infra (I keep these here so devtools can provide "work mode")
    devtools_pacman_work:
      - terraform
      - aws-cli
      - openfortivpn
    
    # If you later decide databricks-cli via AUR, put it here; for now keep empty
    # devtools_aur_work:
    #   - databricks-cli
    
    # ---- Escape hatches for host/group vars ----
    devtools_extra_pacman: []
    devtools_extra_aur: []
    devtools_extra_flatpak: []
    
    # Rustup bootstrap (minimal)
    devtools_enable_rustup_bootstrap: true
    devtools_rustup_default_toolchain: stable
    devtools_rustup_components:
      - rustfmt
      - clippy

===== devtools/tasks/main.yml =====
    ---
    - name: Devtools | Compute package selection
      ansible.builtin.set_fact:
        _devtools_pacman: >-
          {{
            (devtools_pacman_core | default([]))
            + (
                (devtools_pacman_lang | default([]))
                if (devtools_enable_lang | bool) else []
              )
            + (
                (devtools_pacman_containers | default([]))
                if (devtools_enable_containers | bool) else []
              )
            + (
                (devtools_pacman_admin | default([]))
                if (devtools_enable_admin | bool) else []
              )
            + (
                (devtools_pacman_tex_base | default([]))
                if (devtools_enable_tex | bool) else []
              )
            + (
                (devtools_pacman_tex_extra | default([]))
                if (devtools_enable_tex_extra | bool) else []
              )
            + (
                (devtools_pacman_work | default([]))
                if (devtools_mode in ['work', 'full'] ) else []
              )
            + (devtools_extra_pacman | default([]))
          }}
        _devtools_aur: >-
          {{
            (devtools_aur_core | default([]))
            + (devtools_extra_aur | default([]))
          }}
        _devtools_flatpak: "{{ devtools_extra_flatpak | default([]) }}"
    
    - name: Devtools | Apply mode defaults (opinionated)
      ansible.builtin.set_fact:
        devtools_enable_containers: "{{ true if devtools_mode in ['full', 'work'] else devtools_enable_containers }}"
        devtools_enable_admin: "{{ true if devtools_mode in ['full', 'work'] else devtools_enable_admin }}"
        devtools_enable_lang: "{{ true if devtools_mode in ['full', 'work'] else devtools_enable_lang }}"
      when: devtools_mode != 'core'
    
    # Recompute after mode defaults changed
    - name: Devtools | Recompute package selection after mode defaults
      ansible.builtin.set_fact:
        _devtools_pacman: >-
          {{
            (devtools_pacman_core | default([]))
            + ((devtools_pacman_lang | default([])) if (devtools_enable_lang | bool) else [])
            + ((devtools_pacman_containers | default([])) if (devtools_enable_containers | bool) else [])
            + ((devtools_pacman_admin | default([])) if (devtools_enable_admin | bool) else [])
            + ((devtools_pacman_tex_base | default([])) if (devtools_enable_tex | bool) else [])
            + ((devtools_pacman_tex_extra | default([])) if (devtools_enable_tex_extra | bool) else [])
            + ((devtools_pacman_work | default([])) if (devtools_mode in ['work', 'full']) else [])
            + (devtools_extra_pacman | default([]))
          }}
        _devtools_aur: >-
          {{
            (devtools_aur_core | default([]))
            + (devtools_extra_aur | default([]))
          }}
        _devtools_flatpak: "{{ devtools_extra_flatpak | default([]) }}"
    
    - name: Devtools | Install selected packages (pacman/aur/flatpak)
      ansible.builtin.include_role:
        name: packages
        tasks_from: install.yml
      vars:
        packages_pacman_packages: "{{ _devtools_pacman | unique }}"
        packages_aur_packages: "{{ _devtools_aur | unique }}"
        packages_flatpak_packages: "{{ _devtools_flatpak | unique }}"
    
    - name: Devtools | Check if rustup exists
      become: true
      become_user: "{{ ansible_facts.user_id }}"
      ansible.builtin.command: "command -v rustup"
      register: _rustup_present
      changed_when: false
      failed_when: false
    
    - name: Devtools | Ensure default rust toolchain is installed
      become: true
      become_user: "{{ ansible_facts.user_id }}"
      ansible.builtin.command: "rustup toolchain install {{ devtools_rustup_default_toolchain }}"
      when:
        - devtools_enable_rustup_bootstrap | bool
        - _rustup_present.rc == 0
    
    - name: Devtools | Set default rust toolchain
      become: true
      become_user: "{{ ansible_facts.user_id }}"
      ansible.builtin.command: "rustup default {{ devtools_rustup_default_toolchain }}"
      when:
        - devtools_enable_rustup_bootstrap | bool
        - _rustup_present.rc == 0
    
    - name: Devtools | Install rust components (fmt/clippy)
      become: true
      become_user: "{{ ansible_facts.user_id }}"
      ansible.builtin.command: "rustup component add {{ item }}"
      loop: "{{ devtools_rustup_components | default([]) }}"
      when:
        - devtools_enable_rustup_bootstrap | bool
        - _rustup_present.rc == 0
        - (devtools_rustup_components | default([])) | length > 0

===== dotfiles/defaults/main.yml =====
    ---
    dotfiles_teagarden_home: "{{ ansible_facts.env.HOME }}/src/teagarden"
    dotfiles_teagarden_manifest_path: "{{ playbook_dir }}/teagarden/manifest.yml"
    dotfiles_git_transport: "https"   # or ssh
    
    dotfiles_force_links: true
    dotfiles_backup_existing: true
    dotfiles_backup_suffix: ".bk"

===== dotfiles/tasks/apply_link.yml =====
    ---
    - name: Dotfiles | Merge defaults into link
      ansible.builtin.set_fact:
        dotfiles_df_repo_key: "{{ df_link.repo | default(df_defaults.repo | default('teashellf')) }}"
        dotfiles_df_required: "{{ (df_link.required | default(df_defaults.required | default(true))) | bool }}"
        dotfiles_df_path: "{{ df_link.path | default(df_defaults.path | default('')) }}"
        dotfiles_df_src: "{{ df_link.src }}"
        dotfiles_df_dest: "{{ df_link.dest }}"
    
    - name: Dotfiles | Resolve repo info
      ansible.builtin.set_fact:
        dotfiles_df_repo_info: "{{ tg.repos[dotfiles_df_repo_key] | default({}) }}"
        dotfiles_df_repo_path: "{{ (tg.repos[dotfiles_df_repo_key].path if (tg.repos[dotfiles_df_repo_key] is defined) else '') }}"
    
    - name: Dotfiles | Fail if required repo missing from manifest
      ansible.builtin.fail:
        msg: "Required repo '{{ dotfiles_df_repo_key }}' not found in manifest (src={{ dotfiles_df_src }}, dest={{ dotfiles_df_dest }})"
      when:
        - dotfiles_df_required
        - dotfiles_df_repo_info | length == 0
    
    - name: Dotfiles | Resolve source path
      ansible.builtin.set_fact:
        dotfiles_df_src_abs: "{{ dotfiles_teagarden_home }}/{{ dotfiles_df_repo_path }}/{{ dotfiles_df_path }}/{{ dotfiles_df_src }}"
      when: dotfiles_df_repo_info | length > 0
    
    - name: Dotfiles | Start destination expansion
      ansible.builtin.set_fact:
        dotfiles_df_dest_expanded: "{{ dotfiles_df_dest }}"
      when: dotfiles_df_repo_info | length > 0
    
    - name: Dotfiles | Expand destination variables
      ansible.builtin.set_fact:
        dotfiles_df_dest_expanded: "{{ dotfiles_df_dest_expanded | replace(item.key, item.value) }}"
      loop:
        - { key: "$HOME", value: "{{ dotfiles_home }}" }
        - { key: "$XDG_CONFIG_HOME", value: "{{ dotfiles_xdg_config_home }}" }
        - { key: "$XDG_DATA_HOME", value: "{{ dotfiles_xdg_data_home }}" }
        - { key: "$XDG_CACHE_HOME", value: "{{ dotfiles_xdg_cache_home }}" }
        - { key: "$XDG_STATE_HOME", value: "{{ dotfiles_xdg_state_home }}" }
        - { key: "$TEAGARDEN_HOME", value: "{{ dotfiles_teagarden_home }}" }
      when: dotfiles_df_repo_info | length > 0
    
    - name: Dotfiles | Fail if destination still contains unexpanded variables
      ansible.builtin.fail:
        msg: "Destination still contains unexpanded vars: dest='{{ dotfiles_df_dest }}' expanded='{{ dotfiles_df_dest_expanded }}'"
      when:
        - dotfiles_df_repo_info | length > 0
        - dotfiles_df_dest_expanded is search('\\$[A-Z_]+')
    
    - name: Dotfiles | Resolve destination parent
      ansible.builtin.set_fact:
        dotfiles_df_dest_parent: "{{ dotfiles_df_dest_expanded | dirname }}"
      when: dotfiles_df_repo_info | length > 0
    
    - name: Dotfiles | Stat source
      ansible.builtin.stat:
        path: "{{ dotfiles_df_src_abs }}"
      register: dotfiles_df_src_stat
      when: dotfiles_df_repo_info | length > 0
    
    - name: Dotfiles | Fail if required source missing
      ansible.builtin.fail:
        msg: "Required source missing: {{ dotfiles_df_src_abs }} -> {{ dotfiles_df_dest_expanded }}"
      when:
        - dotfiles_df_required
        - dotfiles_df_repo_info | length > 0
        - not dotfiles_df_src_stat.stat.exists
    
    - name: Dotfiles | Skip optional missing source with warning
      ansible.builtin.debug:
        msg: "Skipping optional link (missing source): {{ dotfiles_df_src_abs }} -> {{ dotfiles_df_dest_expanded }}"
      when:
        - not dotfiles_df_required
        - (dotfiles_df_repo_info | length == 0) or (not dotfiles_df_src_stat.stat.exists)
    
    - name: Dotfiles | Ensure destination parent exists
      ansible.builtin.file:
        path: "{{ dotfiles_df_dest_parent }}"
        state: directory
        mode: "0755"
      become: true
      become_user: "{{ ansible_facts.user_id }}"
      when:
        - dotfiles_df_repo_info | length > 0
        - dotfiles_df_src_stat.stat.exists
        - dotfiles_df_dest_parent != dotfiles_home
    
    - name: Dotfiles | Stat destination (no follow)
      ansible.builtin.stat:
        path: "{{ dotfiles_df_dest_expanded }}"
        follow: false
      register: dotfiles_df_dest_stat
      when:
        - dotfiles_df_repo_info | length > 0
        - dotfiles_df_src_stat.stat.exists
    
    - name: Dotfiles | Determine if destination is already correct link
      ansible.builtin.set_fact:
        dotfiles_df_dest_is_correct_link: >-
          {{
            dotfiles_df_dest_stat.stat.islnk
            and (dotfiles_df_dest_stat.stat.lnk_source == dotfiles_df_src_abs)
          }}
      when:
        - dotfiles_df_repo_info | length > 0
        - dotfiles_df_src_stat.stat.exists
        - dotfiles_df_dest_stat.stat.exists | default(false)
    
    - name: Dotfiles | Backup destination (timestamped) before overwrite
      ansible.builtin.command: >-
        mv "{{ dotfiles_df_dest_expanded }}" "{{ dotfiles_df_dest_expanded }}{{ dotfiles_backup_suffix }}.{{ dotfiles_ts }}"
      when:
        - dotfiles_df_repo_info | length > 0
        - dotfiles_df_src_stat.stat.exists
        - dotfiles_df_dest_stat.stat.exists | default(false)
        - not (dotfiles_df_dest_is_correct_link | default(false))
        - dotfiles_force_links | bool
        - dotfiles_backup_existing | bool
      changed_when: true
    
    - name: Dotfiles | Fail if destination exists and force is off
      ansible.builtin.fail:
        msg: "Destination exists and dotfiles_force_links=false: {{ dotfiles_df_dest_expanded }}"
      when:
        - dotfiles_df_repo_info | length > 0
        - dotfiles_df_src_stat.stat.exists
        - dotfiles_df_dest_stat.stat.exists | default(false)
        - not (dotfiles_df_dest_is_correct_link | default(false))
        - not (dotfiles_force_links | bool)
    
    - name: Dotfiles | Create symlink
      ansible.builtin.file:
        src: "{{ dotfiles_df_src_abs }}"
        dest: "{{ dotfiles_df_dest_expanded }}"
        state: link
        force: "{{ dotfiles_force_links | bool }}"
      become: true
      become_user: "{{ ansible_facts.user_id }}"
      when:
        - dotfiles_df_repo_info | length > 0
        - dotfiles_df_src_stat.stat.exists
        - not (dotfiles_df_dest_is_correct_link | default(false))

===== dotfiles/tasks/apply_target_file.yml =====
    ---
    - name: Dotfiles | Read target file from remote
      ansible.builtin.slurp:
        src: "{{ df_target_file }}"
      register: dotfiles_target_slurp
    
    - name: Dotfiles | Parse target YAML # noqa var-naming
      ansible.builtin.set_fact:
        df_file: "{{ (dotfiles_target_slurp.content | b64decode) | from_yaml }}"
    
    - name: Dotfiles | Apply links from target file # noqa var-naming
      ansible.builtin.include_tasks: apply_link.yml
      loop: "{{ df_file.links | default([]) }}"
      loop_control:
        loop_var: df_link
      vars:
        df_defaults: "{{ df_file.defaults | default({}) }}"

===== dotfiles/tasks/main.yml =====
    ---
    - name: Dotfiles | Capture timestamp for backups
      ansible.builtin.set_fact:
        dotfiles_ts: "{{ lookup('pipe', 'date +%Y%m%d-%H%M%S') }}"
    
    - name: Dotfiles | Compute XDG base dirs (defaults if unset)
      ansible.builtin.set_fact:
        dotfiles_home: "{{ ansible_facts.env.HOME }}"
        dotfiles_xdg_config_home: "{{ ansible_facts.env.XDG_CONFIG_HOME | default(ansible_facts.env.HOME + '/.config') }}"
        dotfiles_xdg_data_home: "{{ ansible_facts.env.XDG_DATA_HOME | default(ansible_facts.env.HOME + '/.local/share') }}"
        dotfiles_xdg_cache_home: "{{ ansible_facts.env.XDG_CACHE_HOME | default(ansible_facts.env.HOME + '/.cache') }}"
        dotfiles_xdg_state_home: "{{ ansible_facts.env.XDG_STATE_HOME | default(ansible_facts.env.HOME + '/.local/state') }}"
    
    - name: Dotfiles | Load teagarden manifest
      ansible.builtin.include_vars:
        file: "{{ dotfiles_teagarden_manifest_path }}"
        name: tg
    
    - name: Dotfiles | Ensure TEAGARDEN_HOME exists
      ansible.builtin.file:
        path: "{{ dotfiles_teagarden_home }}"
        state: directory
        mode: "0755"
      become: true
      become_user: "{{ ansible_facts.user_id }}"
    
    - name: Dotfiles | Clone all teagarden repos
      ansible.builtin.git:  # noqa: latest[git]
        repo: "{{ item.value['url_' + dotfiles_git_transport] }}"
        dest: "{{ dotfiles_teagarden_home }}/{{ item.value.path }}"
        update: false
        accept_hostkey: true
      become: true
      become_user: "{{ ansible_facts.user_id }}"
      loop: "{{ tg.repos | dict2items }}"
    
    - name: Dotfiles | Determine targets dir
      ansible.builtin.set_fact:
        dotfiles_targets_dir: "{{ tg.repos['teashellf'].targets_dir | default('targets') }}"
    
    - name: Dotfiles | Find all target files
      ansible.builtin.find:
        paths: "{{ dotfiles_teagarden_home }}/{{ tg.repos['teashellf'].path }}/{{ dotfiles_targets_dir }}"
        patterns: "*.yml"
        file_type: file
      register: dotfiles_target_find
    
    - name: Dotfiles | Apply each targets file
      ansible.builtin.include_tasks: apply_target_file.yml
      loop: "{{ dotfiles_target_find.files }}"
      loop_control:
        loop_var: dotfiles_target_file
      vars:
        df_target_file: "{{ dotfiles_target_file.path }}"

===== hardware/defaults/main.yml =====
    ---
    # hardware: device support (udev, drivers, daemons). Not general apps.
    
    # Auto detection: "auto" tries to detect; true/false forces.
    hardware_enable_laptop: auto        # true|false|auto
    hardware_enable_bluetooth: auto     # true|false|auto
    
    # Peripherals
    hardware_enable_zsa: true
    hardware_enable_plover: false       # opt-in, even if ZSA is enabled
    hardware_enable_logitech: false     # opt-in
    hardware_enable_printer: false      # opt-in
    
    # Firmware updates
    hardware_enable_fwupd: true
    
    # --- Packages ---
    hardware_pacman_packages_bluetooth:
      - bluez
      - bluez-utils
    
    hardware_pacman_packages_laptop:
      - power-profiles-daemon
    
    hardware_pacman_packages_fwupd:
      - fwupd
    
    hardware_pacman_packages_printer:
      - cups
    
    hardware_pacman_packages_zsa:
      # keep this minimal; GUI deps should ideally live in desktop/apps if you prefer
      - libusb
    
    # If you want to keep GUI deps here for ZSA tools (Keymapp/Kontroll), uncomment:
    #  - gtk3
    #  - webkit2gtk
    
    hardware_pacman_packages_logitech:
      # logiops runs a daemon for button remaps / DPI etc.
      - libevdev
    
    hardware_aur_packages_zsa:
      - zsa-kontroll-bin
      - zsa-keymapp-bin
    
    hardware_aur_packages_logitech:
      - logiops
    
    hardware_aur_packages_plover:
      - plover
    
    # --- Paths / files ---
    hardware_zsa_udev_rules_src: "50-zsa.rules"
    hardware_zsa_udev_rules_dest: "/etc/udev/rules.d/50-zsa.rules"

===== hardware/handlers/main.yml =====
    ---
    - name: Reload udev rules
      become: true
      ansible.builtin.command: udevadm control --reload-rules
      changed_when: false

===== hardware/tasks/bluetooth.yml =====
    ---
    - name: Hardware | bluetooth | Install packages
      ansible.builtin.include_role:
        name: packages
        tasks_from: install.yml
      vars:
        packages_pacman_packages: "{{ hardware_pacman_packages_bluetooth }}"
    
    - name: Hardware | bluetooth | Enable service
      become: true
      ansible.builtin.systemd:
        name: bluetooth.service
        enabled: true
        state: started

===== hardware/tasks/fwupd.yml =====
    ---
    - name: Hardware | fwupd | Install packages
      ansible.builtin.include_role:
        name: packages
        tasks_from: install.yml
      vars:
        packages_pacman_packages: "{{ hardware_pacman_packages_fwupd }}"
    
    - name: Hardware | fwupd | Enable service
      become: true
      ansible.builtin.systemd:
        name: fwupd.service
        enabled: true
        state: started

===== hardware/tasks/laptop.yml =====
    ---
    - name: Hardware | laptop | Install power management packages
      ansible.builtin.include_role:
        name: packages
        tasks_from: install.yml
      vars:
        packages_pacman_packages: "{{ hardware_pacman_packages_laptop }}"
    
    - name: Hardware | laptop | Enable power-profiles-daemon
      become: true
      ansible.builtin.systemd:
        name: power-profiles-daemon.service
        enabled: true
        state: started

===== hardware/tasks/logitech.yml =====
    ---
    - name: Hardware | logitech | Install pacman deps
      ansible.builtin.include_role:
        name: packages
        tasks_from: install.yml
      vars:
        packages_pacman_packages: "{{ hardware_pacman_packages_logitech }}"
        packages_aur_packages: "{{ hardware_aur_packages_logitech }}"
    
    - name: Hardware | logitech | Enable logiops daemon
      become: true
      ansible.builtin.systemd:
        name: logid.service
        enabled: true
        state: started

===== hardware/tasks/main.yml =====
    ---
    # --- auto detection ---
    - name: Hardware | Detect laptop (BAT* present)
      ansible.builtin.shell: "ls /sys/class/power_supply/BAT* >/dev/null 2>&1"
      register: hardware_bat_check
      changed_when: false
      failed_when: false
    
    - name: Hardware | Set laptop fact (auto)
      ansible.builtin.set_fact:
        hardware_is_laptop: "{{ hardware_enable_laptop == 'true' or (hardware_enable_laptop == 'auto' and hardware_bat_check.rc == 0) }}"
      when: hardware_enable_laptop in ['auto', 'true', 'false']
    
    - name: Hardware | Set laptop fact (forced)
      ansible.builtin.set_fact:
        hardware_is_laptop: "{{ hardware_enable_laptop | bool }}"
      when: hardware_enable_laptop in ['true', 'false']
    
    - name: Hardware | Detect bluetooth (sysfs)
      ansible.builtin.stat:
        path: /sys/class/bluetooth
      register: hardware_bluetooth_sys
    
    - name: Hardware | Set bluetooth fact (auto)
      ansible.builtin.set_fact:
        hardware_has_bluetooth: >-
          {{
            (hardware_enable_bluetooth == 'true') or
            (hardware_enable_bluetooth == 'auto' and (hardware_bluetooth_sys.stat.exists | default(false)))
          }}
      when: hardware_enable_bluetooth in ['auto', 'true', 'false']
    
    - name: Hardware | Set bluetooth fact (forced)
      ansible.builtin.set_fact:
        hardware_has_bluetooth: "{{ hardware_enable_bluetooth | bool }}"
      when: hardware_enable_bluetooth in ['true', 'false']
    
    # --- feature includes ---
    - name: Hardware | fwupd
      ansible.builtin.include_tasks: fwupd.yml
      when: hardware_enable_fwupd | bool
    
    - name: Hardware | bluetooth
      ansible.builtin.include_tasks: bluetooth.yml
      when: hardware_has_bluetooth | bool
    
    - name: Hardware | laptop power
      ansible.builtin.include_tasks: laptop.yml
      when: hardware_is_laptop | bool
    
    - name: Hardware | printer
      ansible.builtin.include_tasks: printer.yml
      when: hardware_enable_printer | bool
    
    - name: Hardware | logitech
      ansible.builtin.include_tasks: logitech.yml
      when: hardware_enable_logitech | bool
    
    - name: Hardware | zsa keyboards
      ansible.builtin.include_tasks: zsa.yml
      when: hardware_enable_zsa | bool

===== hardware/tasks/printer.yml =====
    ---
    - name: Hardware | printer | Install packages
      ansible.builtin.include_role:
        name: packages
        tasks_from: install.yml
      vars:
        packages_pacman_packages: "{{ hardware_pacman_packages_printer }}"
    
    - name: Hardware | printer | Enable service
      become: true
      ansible.builtin.systemd:
        name: cups.service
        enabled: true
        state: started

===== hardware/tasks/zsa.yml =====
    ---
    - name: Hardware | zsa | Install packages
      ansible.builtin.include_role:
        name: packages
        tasks_from: install.yml
      vars:
        packages_pacman_packages: "{{ hardware_pacman_packages_zsa }}"
        packages_aur_packages: "{{ hardware_aur_packages_zsa }}"
    
    - name: Hardware | zsa | Install udev rules
      become: true
      ansible.builtin.copy:
        src: "{{ hardware_zsa_udev_rules_src }}"
        dest: "{{ hardware_zsa_udev_rules_dest }}"
        owner: root
        group: root
        mode: "0644"
      notify: Reload udev rules

===== packages/tasks/install.yml =====
    ---
    - name: Packages | Install pacman packages
      become: true
      community.general.pacman:
        name: "{{ packages_pacman_packages | default([]) }}"
        state: present
      when: (packages_pacman_packages | default([])) | length > 0
    
    - name: Packages | Install AUR packages (build as user)
      kewlfft.aur.aur:
        name: "{{ packages_aur_packages | default([]) }}"
        state: present
        use: "{{ bootstrap_aur_helper | default('paru') }}"
      become: true
      become_user: aurbuilder
      when: (packages_aur_packages | default([])) | length > 0
    
    - name: Packages | Install flatpaks (user install by default)
      community.general.flatpak:
        name: "{{ packages_flatpak_packages | default([]) }}"
        state: present
        method: "{{ flatpak_method | default('user') }}"
      become: true
      become_user: "{{ ansible_facts.user_id }}"
      when: (packages_flatpak_packages | default([])) | length > 0

===== secrets_mgmt/defaults/main.yml =====
    ---
    # Opinionated baseline secrets stack for your machines.
    
    # Enable full YubiKey tooling (single knob).
    secrets_mgmt_enable_yubikey: true
    
    # Enable python-keyring backend that reads from pass/pass-like store.
    # Arch AUR: python-keyring-pass
    secrets_mgmt_enable_keyring_pass_backend: true
    
    # Base packages: always installed.
    secrets_mgmt_pacman_packages_base:
      - age
      - gnupg
      - age-plugin-yubikey
      - python-keyring
      - oath-toolkit
      - pass-otp
      # Clipboard: install both so Qtile/X11 and Wayland cases are covered
      - xclip
      - wl-clipboard
      - qrencode
      - zbar
    
    # YubiKey packages: installed when enabled.
    secrets_mgmt_pacman_packages_yubikey:
      - libfido2
      - yubikey-manager
      - yubico-piv-tool
      - yubico-pam
      - pam-u2f
      - yubikey-personalization
      - ccid
      - pcsclite
      # - yubioath-desktop
    
    # AUR packages: keep minimal and explicit.
    secrets_mgmt_aur_packages_base:
      - passage-git
      # - yubikey-agent # install is broken
    
    secrets_mgmt_aur_packages_keyring:
      - python-keyring-pass

===== secrets_mgmt/tasks/main.yml =====
    ---
    - name: Secret Management | Build pacman package list
      ansible.builtin.set_fact:
        secrets_mgmt__pacman_packages: >-
          {{
            secrets_mgmt_pacman_packages_base
            + (secrets_mgmt_pacman_packages_yubikey if (secret_mgmt_enable_yubikey | bool) else [])
          }}
    
    - name: Secret Management | Build AUR package list
      ansible.builtin.set_fact:
        secrets_mgmt__aur_packages: >-
          {{
            secrets_mgmt_aur_packages_base
            + (secrets_mgmt_aur_packages_keyring if (secret_mgmt_enable_keyring_pass_backend | bool) else [])
          }}
    
    - name: Secret Management | Install packages via shared packages role
      ansible.builtin.include_role:
        name: packages
        tasks_from: install.yml
      vars:
        packages_pacman_packages: "{{ secrets_mgmt__pacman_packages | unique }}"
        packages_aur_packages: "{{ secrets_mgmt__aur_packages | unique }}"
    
    - name: Secret Management | Enable pcscd (required for CCID/smartcard workflows)
      become: true
      ansible.builtin.systemd:
        name: pcscd
        enabled: true
        state: started
      when: secrets_mgmt_enable_yubikey | bool

===== security_baseline/defaults/main.yml =====
    ---
    # Group / sudo policy
    security_add_user_to_wheel: true
    security_require_wheel_for_sudo: true
    
    security_enable_docker_group: false
    security_add_user_to_docker: false
    
    security_extra_groups: []
    
    # Sysctl
    security_apply_sysctl_baseline: true
    
    # SSH
    security_ensure_sshd_disabled: true
    security_enable_sshd: false
    
    # Firewall (client-side, optional)
    security_enable_firewall: false
    security_firewall_tool: ufw

===== security_baseline/tasks/main.yml =====
    ---
    - name: Security | Ensure wheel group exists
      become: true
      ansible.builtin.group:
        name: wheel
        state: present
    
    - name: Security | Add user to wheel group
      become: true
      ansible.builtin.user:
        name: "{{ ansible_user_id }}"
        groups: wheel
        append: true
      when: security_add_user_to_wheel | bool
    
    - name: Security | Ensure docker group exists (optional)
      become: true
      ansible.builtin.group:
        name: docker
        state: present
      when: security_enable_docker_group | bool
    
    - name: Security | Add user to docker group (optional)
      become: true
      ansible.builtin.user:
        name: "{{ ansible_user_id }}"
        groups: docker
        append: true
      when:
        - security_enable_docker_group | bool
        - security_add_user_to_docker | bool
    
    - name: Security | Add user to extra groups
      become: true
      ansible.builtin.user:
        name: "{{ ansible_user_id }}"
        groups: "{{ security_extra_groups }}"
        append: true
      when: (security_extra_groups | default([])) | length > 0
    
    # ---- sudo baseline ----
    - name: Security | Ensure sudoers.d exists
      become: true
      ansible.builtin.file:
        path: /etc/sudoers.d
        state: directory
        owner: root
        group: root
        mode: "0750"
    
    - name: Security | Install sudo baseline policy
      become: true
      ansible.builtin.template:
        src: sudoers-10-security-baseline.j2
        dest: /etc/sudoers.d/10-security-baseline
        owner: root
        group: root
        mode: "0440"
        validate: "visudo -cf %s"
    
    # ---- sysctl baseline ----
    - name: Security | Install sysctl baseline config
      become: true
      ansible.builtin.template:
        src: sysctl-50-security-baseline.conf.j2
        dest: /etc/sysctl.d/50-security-baseline.conf
        owner: root
        group: root
        mode: "0644"
      when: security_apply_sysctl_baseline | bool
    
    - name: Security | Reload sysctl
      become: true
      ansible.builtin.command: sysctl --system
      changed_when: false
      when: security_apply_sysctl_baseline | bool
    
    # ---- sshd assertion ----
    - name: Security | Ensure sshd is disabled unless explicitly enabled
      become: true
      ansible.builtin.systemd:
        name: sshd.service
        enabled: false
        state: stopped
      when:
        - security_ensure_sshd_disabled | bool
        - not (security_enable_sshd | bool)
    
    # ---- optional firewall ----
    - name: Security | Install ufw (optional)
      ansible.builtin.include_role:
        name: packages
        tasks_from: install.yml
      vars:
        packages_pacman_packages:
          - ufw
      when:
        - security_enable_firewall | bool
        - security_firewall_tool == 'ufw'
    
    - name: Security | Enable ufw with client policy (optional)
      become: true
      ansible.builtin.command: "{{ item }}"
      loop:
        - ufw --force reset
        - ufw default deny incoming
        - ufw default allow outgoing
        - ufw --force enable
      changed_when: false
      when:
        - security_enable_firewall | bool
        - security_firewall_tool == 'ufw'

===== storage/defaults/main.yml =====
    ---
    # storage: safe baseline tools + optional snapper + optional backup tools
    
    # Baseline packages (safe everywhere)
    storage_enable_baseline_tools: true
    
    # Snapper snapshots (Btrfs only). This role will refuse to configure snapper if / is not btrfs.
    storage_enable_snapper: true
    storage_enable_snapper_pacman_hooks: true   # uses snap-pac on Arch
    
    # Timeline schedule: keep it simple and conservative
    storage_snapper_timeline_oncalendar: "weekly"   # systemd OnCalendar value
    storage_snapper_timeline_randomized_delay_sec: "1h"
    
    # Retention policy (approx 2-3 months)
    # Snapper config keys: TIMELINE_LIMIT_HOURLY/DAILY/WEEKLY/MONTHLY/YEARLY
    storage_snapper_timeline_limits:
      hourly: "0"
      daily: "0"
      weekly: "12"
      monthly: "0"
      yearly: "0"
    
    # Backup tool install (manual usage only, no timers/services configured)
    storage_backup_tool: "borg"   # borg|restic|none
    
    # --- Packages ---
    storage_pacman_packages_baseline:
      # filesystem tools
      - util-linux
      - e2fsprogs
      - dosfstools
      - exfatprogs
      - ntfs-3g
      - btrfs-progs
    
      # inspection / convenience
      - rsync
      - compsize
    
      # compression / archives (handy everywhere)
      - tar
      - unzip
      - zip
      - p7zip
      - zstd
      - gzip
      - bzip2
      - xz
     # drive utils
      - parted
      - nvme-cli
      - smartmontools
    
    storage_pacman_packages_snapper:
      - snapper
    
    storage_pacman_packages_snapper_hooks:
      - snap-pac
    
    storage_pacman_packages_borg:
      - borg
    
    storage_pacman_packages_restic:
      - restic
    
    # Snapper config name and target
    storage_snapper_config_name: "root"
    storage_snapper_config_path: "/"

===== storage/tasks/main.yml =====
    ---
    - name: Storage | Install baseline tools
      ansible.builtin.include_role:
        name: packages
        tasks_from: install.yml
      vars:
        packages_pacman_packages: "{{ storage_pacman_packages_baseline }}"
      when: storage_enable_baseline_tools | bool
    
    - name: Storage | Install backup tool (manual use only)
      ansible.builtin.include_role:
        name: packages
        tasks_from: install.yml
      vars:
        packages_pacman_packages: >-
          {{
            (storage_pacman_packages_borg if storage_backup_tool == 'borg' else [])
            + (storage_pacman_packages_restic if storage_backup_tool == 'restic' else [])
          }}
      when: storage_backup_tool in ['borg', 'restic']
    
    - name: Storage | Configure snapper
      ansible.builtin.include_tasks: snapper.yml
      when: storage_enable_snapper | bool

===== storage/tasks/snapper.yml =====
    ---
    - name: Storage | snapper | Ensure snapper installed
      ansible.builtin.include_role:
        name: packages
        tasks_from: install.yml
      vars:
        packages_pacman_packages: >-
          {{
            storage_pacman_packages_snapper
            + (storage_pacman_packages_snapper_hooks if storage_enable_snapper_pacman_hooks | bool else [])
          }}
    
    - name: Storage | snapper | Assert root filesystem is btrfs
      ansible.builtin.assert:
        that:
          - ansible_facts.mounts | selectattr('mount', 'equalto', '/') | list | length > 0
          - (ansible_facts.mounts | selectattr('mount', 'equalto', '/') | first).fstype == 'btrfs'
        fail_msg: "Snapper requested but / is not btrfs. Refusing to configure snapper."
    
    - name: Storage | snapper | Check if snapper config exists
      ansible.builtin.stat:
        path: "/etc/snapper/configs/{{ storage_snapper_config_name }}"
      register: storage_snapper_cfg
    
    - name: Storage | snapper | Create snapper config (only if missing)
      become: true
      ansible.builtin.command: "snapper -c {{ storage_snapper_config_name }} create-config {{ storage_snapper_config_path }}"
      when: not storage_snapper_cfg.stat.exists
      changed_when: true
    
    # Retention policy: edit /etc/snapper/configs/root
    - name: Storage | snapper | Configure timeline retention limits
      become: true
      ansible.builtin.lineinfile:
        path: "/etc/snapper/configs/{{ storage_snapper_config_name }}"
        regexp: "^{{ item.key }}="
        line: "{{ item.key }}=\"{{ item.value }}\""
        create: false
      loop:
        - { key: "TIMELINE_LIMIT_HOURLY", value: "{{ storage_snapper_timeline_limits.hourly }}" }
        - { key: "TIMELINE_LIMIT_DAILY", value: "{{ storage_snapper_timeline_limits.daily }}" }
        - { key: "TIMELINE_LIMIT_WEEKLY", value: "{{ storage_snapper_timeline_limits.weekly }}" }
        - { key: "TIMELINE_LIMIT_MONTHLY", value: "{{ storage_snapper_timeline_limits.monthly }}" }
        - { key: "TIMELINE_LIMIT_YEARLY", value: "{{ storage_snapper_timeline_limits.yearly }}" }
    
    # Schedule: override snapper-timeline.timer to weekly
    - name: Storage | snapper | Create systemd override dir for snapper-timeline.timer
      become: true
      ansible.builtin.file:
        path: /etc/systemd/system/snapper-timeline.timer.d
        state: directory
        mode: "0755"
    
    - name: Storage | snapper | Install snapper-timeline.timer override (weekly)
      become: true
      ansible.builtin.copy:
        dest: /etc/systemd/system/snapper-timeline.timer.d/override.conf
        mode: "0644"
        content: |
          [Timer]
          OnCalendar=
          OnCalendar={{ storage_snapper_timeline_oncalendar }}
          RandomizedDelaySec={{ storage_snapper_timeline_randomized_delay_sec }}
          Persistent=true
    
    - name: Storage | snapper | Reload systemd
      become: true
      ansible.builtin.systemd:
        daemon_reload: true
    
    - name: Storage | snapper | Enable timers (timeline + cleanup)
      become: true
      ansible.builtin.systemd:
        name: "{{ item }}"
        enabled: true
        state: started
      loop:
        - snapper-timeline.timer
        - snapper-cleanup.timer

===== uv_tools/defaults/main.yml =====
    ---
    uv_tools_enable: true
    
    # Tools you always want (stable daily-use)
    uv_tools_required:
      - buku
      - pypi-command-line
    
    # Tools youre experimenting with (opt-in)
    uv_tools_extras: []
    # example:
    # uv_tools_extras:
    #   - cobib
    #   - papis

===== uv_tools/tasks/main.yml =====
    ---
    - name: UV Tools | Ensure uv is installed
      ansible.builtin.include_role:
        name: packages
        tasks_from: install.yml
      vars:
        packages_pacman_packages:
          - python-uv
      when: uv_tools_enable | bool
    
    - name: UV Tools | Ensure ~/.local/bin exists
      become: true
      become_user: "{{ ansible_facts.user_id }}"
      ansible.builtin.file:
        path: "{{ ansible_env.HOME }}/.local/bin"
        state: directory
        mode: "0755"
      when: uv_tools_enable | bool
    
    - name: UV Tools | Install required uv tools (user scope)
      become: true
      become_user: "{{ ansible_facts.user_id }}"
      ansible.builtin.command: "uv tool install {{ item }}"
      loop: "{{ (uv_tools_required | default([])) + (uv_tools_extras | default([])) }}"
      register: uv_tool_install
      changed_when: >
        ('Installed' in (uv_tool_install.stdout | default('')))
        or ('installed' in (uv_tool_install.stdout | default('')))
        or ('Updated' in (uv_tool_install.stdout | default('')))
        or ('updated' in (uv_tool_install.stdout | default('')))
      when:
        - uv_tools_enable | bool
        - ((uv_tools_required | default([])) + (uv_tools_extras | default([]))) | length > 0

